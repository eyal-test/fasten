/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilitystatementsprocessor;

import com.google.gson.Gson;
import eu.fasten.analyzer.vulnerabilitystatementsprocessor.db.MetadataUtility;
import eu.fasten.analyzer.vulnerabilitystatementsprocessor.utils.FastenApiClient;
import eu.fasten.core.data.vulnerability.Purl;
import eu.fasten.core.data.vulnerability.Vulnerability;
import eu.fasten.core.plugins.DBConnector;
import eu.fasten.core.plugins.KafkaPlugin;
import org.jooq.DSLContext;
import org.pf4j.Extension;
import org.pf4j.Plugin;
import org.pf4j.PluginWrapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.text.ParseException;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

import static eu.fasten.core.data.vulnerability.Vulnerability.sortPurls;

public class VulnerabilityStatementsProcessor extends Plugin {

    public VulnerabilityStatementsProcessor(PluginWrapper wrapper) {
        super(wrapper);
    }

    @Extension
    public static class VulnerabilityStatementsKafkaPlugin implements KafkaPlugin, DBConnector {
        private List<String> consumeTopics = new LinkedList<>(Collections.singletonList("fasten.Vulnerabilities.out"));
        private final String baseOutputPath = File.separator + "vulnerabilities" + File.separator + "processed_statements";
        private String outputPath;
        private static Map<String, DSLContext> contexts;
        private Exception pluginError = null;
        private Vulnerability lastProcessedVulnerability = null;
        private final Gson gson = new Gson();
        private MetadataUtility metadataUtility;
        public final static String[] extensions = new String[]{".java", ".py", ".pyw", ".c", ".cpp", ".h"};
        private final static Logger logger = LoggerFactory.getLogger("VulnerabilityStatementsKafkaPlugin");
        private FastenApiClient fastenApiClient = new FastenApiClient();

        @Override
        public void setDBConnection(Map<String, DSLContext> dslContexts) {
            contexts = dslContexts;
        }

        @Override
        public Optional<List<String>> consumeTopic() {
            return Optional.of(consumeTopics);
        }

        @Override
        public void setTopics(List<String> consumeTopics) {
            this.consumeTopics = consumeTopics;
        }

        @Override
        public void consume(String record) {
            this.pluginError = null;
            try {
                var vulnerability = gson.fromJson(record, Vulnerability.class);
                logger.info("Read vulnerability statement " + vulnerability.getId() + " from " + consumeTopics.toString());
                refreshMetadataUtility();
                var vulnerabilityId = insertVulnerability(vulnerability);
                updateCallablesAndPackageVersions(vulnerability, vulnerabilityId);
                outputPath = baseOutputPath + File.separator + vulnerability.getId() + ".json";
                lastProcessedVulnerability = vulnerability;
            } catch (Exception e) {
                logger.error("Error processing vulnerability statement: " + e);
                setPluginError(e);
            }
        }

        @Override
        public Optional<String> produce() {
            if (lastProcessedVulnerability == null) {
                return Optional.empty();
            } else {
                return Optional.of(gson.toJson(lastProcessedVulnerability));
            }
        }

        @Override
        public String getOutputPath() {
            return outputPath;
        }

        @Override
        public String name() {
            return "Vulnerability Statements Processor";
        }

        @Override
        public String description() {
            return "Reads vulnerabilities from " + consumeTopics.toString() +
                    " and injects them in the database.";
        }

        @Override
        public String version() {
            return "0.0.1";
        }

        @Override
        public void start() {
        }

        @Override
        public void stop() {
        }

        @Override
        public Exception getPluginError() {
            return pluginError;
        }

        public void setPluginError(Exception throwable) {
            this.pluginError = throwable;
        }

        @Override
        public void freeResource() {
        }

        public void refreshMetadataUtility() {
            metadataUtility = new MetadataUtility();
        }

        public void setMetadataUtility(MetadataUtility metadataUtility) {
            this.metadataUtility = metadataUtility;
        }

        public void setFastenApiClient(FastenApiClient client) {
            this.fastenApiClient = client;
        }

        public Long insertVulnerability(Vulnerability v)  {
            var context = getDBContext(v);

            v.filterUnsupportedPatches(extensions);
            try {
                v.updatePatchDate();
            } catch (ParseException e) {
                logger.warn(v.getId() + ": Error updating patch date, continuing: " + e);
            }

            logger.info(v.getId() + ": Inserting vulnerability into the database for ecosystem " + "\"" + v.getEcosystem() + "\".");
            return metadataUtility.insertVulnerability(v, context);
        }

        public void updateCallablesAndPackageVersions(Vulnerability v, Long vulnerabilityId) {
            var context = getDBContext(v);
            var allPurls = v.getValidatedPurls();
            var pkgIds = metadataUtility.getPackageIds(context, allPurls);
            if (pkgIds.size() > 0) {
                for(var pkgId : pkgIds.entrySet()) {
                    updateCallablesAndPackageVersions(v, vulnerabilityId, pkgId.getKey(), pkgId.getValue(), context);
                }
            }
            else {
                updateCallablesAndPackageVersions(v, vulnerabilityId, "", -1L, context);
                logger.info(v.getId() + ": No matching packages found in database.");
            }
        }

        public void updateCallablesAndPackageVersions(Vulnerability v, Long vulnerabilityId, String packageName, Long pkgId, DSLContext context) {
            var vulnerablePackageVersionIds = updateVulnerablePackageVersions(v, vulnerabilityId, packageName, pkgId, context);
            updateVulnerableCallables(v, vulnerabilityId, pkgId, vulnerablePackageVersionIds, context);
            if (vulnerablePackageVersionIds.size() == 0) {
                logger.info(v.getId() + ": No matching package-versions found in database.");
            }
        }

        private List<Long> updateVulnerablePackageVersions(Vulnerability v, Long vulnerabilityId, String packageName, Long pkgId, DSLContext context) {
            var purls = getPurlsForPackage(v.getValidatedPurls(), packageName);
            var pkgIdMap = new HashMap<String, Long>();
            pkgIdMap.put(packageName, pkgId);
            var vulnerablePackageVersionIds= metadataUtility.getPackageVersionIds(purls, context, pkgIdMap);

            logger.info(v.getId() + ": Inserting data for " + vulnerablePackageVersionIds.size() + " vulnerable package-versions into the database.");
            vulnerablePackageVersionIds.forEach(id -> metadataUtility.injectPackageVersionVulnerability(v, id, context));
            metadataUtility.insertVulnerabilityToPackageVersions(vulnerabilityId, vulnerablePackageVersionIds, context);
            return vulnerablePackageVersionIds;
        }

        private LinkedHashSet<Purl> getPurlsForPackage(LinkedHashSet<Purl> purls, String packageName) {
            return sortPurls(purls.stream()
                .filter(p -> packageName.equals(p.getPackageName()))
                .collect(Collectors.toCollection(LinkedHashSet::new)));
        }

        private void updateVulnerableCallables(Vulnerability v, Long vulnerabilityId, Long pkgId, List<Long> vulnerablePackageVersionIds, DSLContext context) {
            var vulnerableFastenUris = new HashSet<String>();
            vulnerableFastenUris.addAll(findFastenUrisInLastVulnerableVersion(v, pkgId, context));
            vulnerableFastenUris.addAll(findFastenUrisInFirstPatchedVersion(v, pkgId, context));
            var vulnerableCallables = findVulnerableCallables(vulnerableFastenUris, vulnerablePackageVersionIds, context);
            var vulnerableCallableIds = vulnerableCallables.keySet();
            v.setFastenUris(new HashSet<>(vulnerableCallables.values()));

            logger.info(v.getId() + ": Inserting data for " + vulnerableCallableIds.size() + " vulnerable callables into the database.");
            vulnerableCallableIds.forEach(id -> metadataUtility.injectCallableVulnerability(v, id, context));
            metadataUtility.insertVulnerabilityToCallables(vulnerabilityId, vulnerableCallableIds, context);
        }

        public DSLContext getDBContext(Vulnerability v) {
            var ecosystem = v.getEcosystem();
            var context = ecosystem.equals("") ? null : contexts.get(ecosystem);
            if (context == null) {
                throw new UnsupportedOperationException(v.getId() + ": Malformed ecosystem data or unsupported ecosystem \"" + ecosystem + "\"");
            }
            return context;
        }

        private HashSet<String> findFastenUrisInLastVulnerableVersion(Vulnerability v, Long pkgId, DSLContext context) {
            var lastVulnerablePurl = getLastVulnerablePurl(v);
            var lastVulnVersionId = findIdForPurl(lastVulnerablePurl, pkgId, context);
            var fastenUris = new HashSet<String>();
            if(lastVulnVersionId != -1L) {
                v.getPatches().forEach(p -> {
                    logger.info(v.getId() + ": Searching for callables in " + p.getFileName() + " for package-version: " + lastVulnVersionId);
                    fastenUris.addAll(metadataUtility.getFastenUrisForPatch(p.getFileName(),
                            p.getOriginalChangedLineNumbers(),
                            lastVulnVersionId, context));
                });
            }
            else {
                logger.info(v.getId() + ": could not find package-version in DB for last vulnerable purl: " + lastVulnerablePurl + ", skipping callables.");
                if(fastenApiClient.getApiUrl() != null) {
                    requestPurlIngestion(v, lastVulnerablePurl);
                }
            }
            return fastenUris;
        }

        private void requestPurlIngestion(Vulnerability v, Purl p) {
            try {
                logger.info(v.getId() + ": calling FASTEN API to ingest package-version for purl: " + p);
                var response = fastenApiClient.requestPackageVersion(v.getEcosystem(), p.getPackageName(), p.getVersion().toString());
                var code = response.statusCode();
                if(code != 201) {
                    logger.warn(v.getId() + ": unexpected response " + code + " to ingest request for purl" + p);
                }
            } catch (Exception e) {
                logger.warn(v.getId() + ": there was a problem calling FASTEN API for purl " + p + " : " + e);
            }
        }

        private Purl getLastVulnerablePurl(Vulnerability v) {
            Purl[] purls = new Purl[v.getValidatedPurls().size()];
            assert purls.length > 0;
            purls = v.getValidatedPurls().toArray(purls);
            return purls[purls.length - 1];
        }

        private HashSet<String> findFastenUrisInFirstPatchedVersion(Vulnerability v, Long pkgId, DSLContext context) {
            var firstPatchedVersionId = findIdForPurl(getFirstPatchedPurl(v), pkgId, context);
            var fastenUris = new HashSet<String>();
            if(firstPatchedVersionId != -1L) {
                v.getPatches().forEach(p -> {
                    logger.info(v.getId() + ": Searching for callables in " + p.getFileName() + " for package-version: " + firstPatchedVersionId);
                    fastenUris.addAll(metadataUtility.getFastenUrisForPatch(p.getFileName(),
                            p.getNewChangedLineNumbers(),
                            firstPatchedVersionId, context));
                });
            }
            return fastenUris;
        }

        private Purl getFirstPatchedPurl(Vulnerability v) {
            Purl[] purls = new Purl[v.getValidatedFirstPatchedPurls().size()];
            if (purls.length > 0) {
                purls = v.getValidatedFirstPatchedPurls().toArray(purls);
                return purls[0];
            }
            return null;
        }

        private Long findIdForPurl(Purl purl, Long pkgId, DSLContext context) {
            if (purl != null && pkgId != -1) {
                return metadataUtility.getPackageVersionId(purl, context, pkgId);
            }
            return -1L;
        }

        private HashMap<Long, String> findVulnerableCallables(HashSet<String> vulnerableFastenUris, List<Long> vulnPkgVersionIds, DSLContext context) {
            var vulnerableCallables = new HashMap<Long, String>();
            vulnerableFastenUris.forEach(uri -> {
                var callIds = metadataUtility.getCallableIdsForFastenUri(uri, new HashSet<>(vulnPkgVersionIds), context);
                callIds.forEach(id -> vulnerableCallables.put(id, metadataUtility.getFullFastenUri(uri, id)));
            });
            return vulnerableCallables;
        }
    }
}
